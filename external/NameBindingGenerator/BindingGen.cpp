/**
 * @file NameBindingGenerator.cpp
 * @author DeinsOne (deinsone@gmail.com)
 * @brief Programm for generating "IdNameBinding.hpp". It takes classes names from <td/telegram/td_api.h>
 * and bind them with their ids
 * @date 2022-05-25
 */

#include <cstdio>
#include <string>
#include <cstring>

#include <fstream>
#include <vector>

#if !defined(WIN32)
    #include <experimental/filesystem>
    namespace fs = std::experimental::filesystem;
#else
    #include <filesystem>
    namespace fs = std::filesystem;
#endif

std::string cutClassName(const std::string& definitionLine) {
    const std::string classDefString = "class ";

    auto cls = definitionLine.find(classDefString);

    auto spacePos = definitionLine.find(" ", cls + classDefString.size());
    auto semicolPos = definitionLine.find(":", cls + classDefString.size());

    if (spacePos < semicolPos) {
        return definitionLine.substr(cls + classDefString.size(), spacePos - (cls + classDefString.size()));
    }
    else {
        return definitionLine.substr(cls + classDefString.size(), semicolPos - (cls + classDefString.size()));
    }
}

int main(int argc, char** argv) {
    // Print help info
    if (argc == 2) {
        if (!strcmp(argv[1], "--help")) {
            printf("Usage:\n");
            printf("  binding_gen [INPUT HEADER PATH] [OUTPUT HEADER PATH]\n\n");
            return 0;
        }
    }
    // Validate paths
    else if (argc == 3) {
        if (
            !fs::exists(fs::path(argv[1])) ||
            !fs::is_regular_file(fs::path(argv[1]))
        ) {
            printf("Err: bad input file, path doesn't exist -> '%s'\n", argv[1]);
            return 1;
        }
    }
    // Bad arguments
    else {
        printf("Err: bad arguments. Use --help to get usage info\n");
    }


    // Generated data
    std::vector<std::string> classDefinitions;                      // class definition line
    std::vector<std::pair<std::string,std::string>> classInfo;      // name, id
    

    // Open input header for reading
    std::ifstream inputHeader(argv[1]);

    // Read input header content
    std::string inputHeaderContent(
        (std::istreambuf_iterator<char>(inputHeader)),
        std::istreambuf_iterator<char>()
    );

    // Set position to begin
    inputHeader.seekg(0, std::ios::beg);

    // Iterate each line and store class definition lines
    for (std::string line; std::getline(inputHeader, line); ) {
        if (line.find("class ") != std::string::npos && line.find("{") != std::string::npos) {
            classDefinitions.push_back(line);
        }
    }

    // Close opened header file
    inputHeader.close();


    // Analyze and fill class information
    for (std::size_t i = 0; i < classDefinitions.size(); i++) {
        auto definition = inputHeaderContent.find(classDefinitions.at(i));
        auto definitionEnd = inputHeaderContent.find("};", definition);

        std::string classBlock = inputHeaderContent.substr(definition, definitionEnd - definition + 2);

        const static std::string stid = "static const std::int32_t ID = ";
        auto idStatic = classBlock.find(stid);
        if (idStatic != std::string::npos) {
            std::string idString = classBlock.substr(idStatic + stid.size(), classBlock.find(";", idStatic) - (idStatic + stid.size()) );

            classInfo.emplace_back(std::pair<std::string,std::string>{cutClassName(classDefinitions.at(i)), idString });
        }
    }


    // Write generated result
    std::ofstream outputHeader(argv[2]);

    outputHeader << "// Generated by binding_gen\n\n";

    outputHeader << "#ifndef tdlpp_IdNameBinding" << "\n";
    outputHeader << "#define tdlpp_IdNameBinding" << "\n";
    outputHeader << "\n";
    outputHeader << "#include <tdlpp/core.hpp>" << "\n";
    outputHeader << "\n";
    outputHeader << "namespace tdlpp { namespace log {" << "\n";
    outputHeader << "\n";
    outputHeader << "static inline std::string __IdNameBinding(const std::int32_t& t_id) {" << "\n";
    outputHeader << "    switch (t_id) {" << "\n";

    for (std::size_t i = 0; i < classInfo.size(); i++) {
        outputHeader << "        case (td::td_api::" << classInfo.at(i).first << "::ID): { return \"" << classInfo.at(i).first << "\"; }" << "\n";
    }

    outputHeader << "        default: { return \"'UNKNOWN Id to Name binding' typeid: \" + std::to_string(t_id); }" << "\n";
    outputHeader << "    };" << "\n";
    outputHeader << "}" << "\n";
    outputHeader << "} // namespace log\n} // namespace tdlpp" << "\n";
    outputHeader << "\n";
    outputHeader << "#endif // tdlpp_IdNameBinding" << "\n";

    outputHeader.close();

    return 0;
}
